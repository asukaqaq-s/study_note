
在介绍 OS 之前，有必要介绍硬件为应用程序提供的执行环境。操作系统需要管理应用程序，而应用程序的很多状态都保存在硬件环境中，譬如：

- 执行哪一条指令
- 上一条指令是否溢出
- 栈内存中位置
- 硬件的状态、初始化、保存恢复

## 1. 程序的运行：指令序列控制处理器

**C语言-->汇编指令-->机器指令**：

- **机器指令**：处理器执行，功能简单，格式固定
- **汇编指令**：与机器指令一一对应，方便程序员理解
- **C语言**：字节码，方便编写

编译工具将程序语言编译为汇编语言，汇编为机器语言，二进制保存在文件中。可以用不同编译器、编译选项，将高级语言源文件编译成不同但等价的汇编程序，而汇编程序只会被汇编成同一份机器程序。

**ISA**：

对于机器指令格式、行为及处理器在执行中的状态规范，称为指令集架构ISA

ISA 就是处理器向软件提供的接口，将实现与接口解耦合。因此华为处理器与高通的ISA相同，即使处理器的实现细节不同，但是在用户程序的角度，使用的方式一样。

**程序计数器与指令执行顺序**：

顺序执行、跳转执行

- **顺序执行**：PC 寄存器 += 指令长度
- **跳转执行**：将PC 寄存器修改为目标值，称为控制流跳转、跳转执行

> arm 中如何用 branch 分支语句，实现 c语言中所有分支与循环类型？

if/else：
```c
bne ... // 如果条件成立
b ...   // else
```

**do/while**：
```c
begin: 
代码段
bxx begin // 如果条件满足回到 begin
... // 不满足继续执行
```

**while**：
```c
bxx finish // 先判断是否满足条件
begin: 
代码段
bxx begin // 如果条件满足回到 begin
finish: 
```

## 2. 处理数据：寄存器、运算、访存

### 2.1 寄存器

寄存器分类：

- **通用寄存器**：存储任意数据的寄存器，aarch64  31个，运算时，存储源数据和运算结果；访存时，存储要访问的内存位置；调用函数时，存储传递的参数
- **特殊寄存器**：栈寄存器、下一条指令内存位置 PC寄存器、条件码寄存器。在后面章节介绍

![img](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_023820.png)

每一个 64 位的寄存器 Xi，有一个对应的 32位寄存器Wi，即Xi的低32位。

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_024019.png)

### 2.1 运算

几种运算语句：

```c
// Rn 和 op2 可以是寄存器或者是立即数
// 对 Rn 与 op 进行运算, 结果存储在 Rd 中
add Rd, Rn, op2          // 加法运算 
sub Rd, Rn, op2          // 减法
mul Rd, Rn, op2          // 乘法
div Rd, Rn, op2          // 除法
neg Rd, Rn               // 取相反数


and Rd, Rn, op2          // 按位与
orr Rd, Rn, op2          // 按位或
eor Rd, Rn, op2          // 按位异或
mvn Rd, Rn, op2          // 按位取反

asr Rd, Rn, op2          // 算术右移
lsl  Rd, Rn, op2         // 逻辑左移
lsr  Rd, Rn, op2         // 逻辑右移
ror  Rd, Rn, op2         // 循环右移

mov Rd, Op2              // 数据移动
```


```c
ADD W0, W1, W2, LSL #3  // W0 = W1 + (W2 << 3) 
SUBS X0, X4, X3, ASR #2 // X0 = X4 - (X3 >> 2), set flags 
MOV X0, X1 // Copy X1 to X0 
CMP W3, W4 // Set flags based on W3 - W4 
ADD W0, W5, #27 // W0 = W5 + 27
```

W2，LSL #3 表示将 W2 逻辑左移的结果作为 ADD 的源数据。


> 若 xi 存储的数据大小小于 32 位，算数右移 x0、x1  w0、w1 得到的结果不同

### 2.3 访存

**一般读写内存的操作**：

- 数据从内存中加载到寄存器
- 再将结果写回内存

x86的读写内存操作过于复杂，使用 mov 指令完成。arm 为了简便，分为**加载指令：读内存值**和**存储指令：写回内存**。

加载指令与存储指令如下：

```c
ldr R, addr      // 内存加载数据到寄存器
ldp R1, R2, addr // 内存加载数据到两个寄存器
str R,addr      
stp R1, R2, addr
```

ldr、str 只用于单个寄存器，以 ldr 为例，假如 R 为 4 字节，就读取 `[addr，addr + 4]` 的数据到寄存器 R 中。ldp、stp 用于两个寄存器，以 ldp 为例，假如 R1、R2 为 4 字节，就读取 `[addr, addr + 4]` 的数据到 R1，读取 `[addr + 4, addr + 8]` 的数据到 R2。

**实例**：

```c
int temp = *a;
*a = *b;
*b = temp;
```

```c
swap:
	ldr w3, [x1] // 取a
	ldr w2, [x0] // 取b
	str w3, [x0] // a 写到b
	str w2, [x1] // b 写到a
```

以上是实现 swap 操作的 arm 汇编代码：

- x0、x1 分别为 b、a 指针，在寄存器中作为 64 位地址存储
- 将 a 数据读取到 w3 中、b 数据读取到 w2 中
- 将 w3 写回到 b，w2 写回到a


**偏移量寻址、索引寻址**

- `[base, offset]` ：base + offset = 目标地址
- `[base, offset]!` ：base 作为目标地址，在寻址操作前将 base 更新为 base+offset
- `[base], offset`： base 作为目标地址，在寻址操作后将 base 更新为 base+offset

寄存器的存储方式：寄存器 xi 中高32位存储数据的高位字节，wi 也就是 xi 的低32位存储数据的低位字节。而内存中以小端序存储：例如一个八字节的数据，在 `[addr, addr + 4)` 存储低4位字节，在 `[addr + 4, addr + 8)` 存储高4位字节。


## 3. 程序分支

标签：.L3、L3 可以用来跳转

条件码存储在状态寄存器中，AArch64 中是 PSTATE 寄存器，ISA 将所有复杂的条件表示为寥寥几个特征的组合，条件位为：

- N 负数 
- Z 整数 
- C 进位 
- V 溢出

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_042211.png)

- 带 s 的运算指令可以用来更新条件码，比如 `subs` 根据减法运算的结果更新条件码，由于没有目的寄存器，所以不会更新寄存器
- cmp、cmn、test 更新运算指令，分别是根据操作数之差，操作数之和，操作数相与来更新条件码

## 4. 调用、返回、栈

### 4.1 函数调用指令、返回指令

ISA 一般会提供专门的函数调用和返回指令，在函数运行的过程中会使用部分栈内存存放调用参数和局部变量。ISA 通过运行时栈为每个函数的实例分配可供临时使用的内存，并在函数返回后释放。

**x86**：

- call 调用函数，返回地址存储到栈中
- ret 函数返回，从栈中读取到返回地址

**aarch64**：

- bl 调用，返回地址存储到特定寄存器 LR（link register）寄存器中，又叫 x30
- ret 函数返回，从 LR 寄存器中读取返回地址，并修改 PC 寄存器 = LR


### 4.2 运行时栈

每个函数实例都需要一些内存保存函数的执行状态，称为栈帧

- **栈顶**：处理器保存栈顶地址到寄存器 SP（stack pointer）
- **栈帧起始**：处理器会保存当前函数栈帧起始地址到 FP （frame pointer）

C语言栈帧由编译器决定，不同编译器有不同的栈帧结构。

为了防止 FP 被修改，被调用者会在修改 FP 前将调用者的 FP 保存到被调用者的栈帧中。那么，FP 可以被用来栈追踪，获取调用链中每个函数的栈帧。由于不是每个函数都会有栈帧，所以让被调用者负责保存 FP 能够提高效率。



```c
square:
1	mul w0, w0, w0
2	ret

cube:
3	stp x29, x30, [sp, -32] ! # 前索引
4	mov x29, sp
5	...
6	bl square
7	mul w0, w0, w19
8   ldr x19, [sp, 16]
9   ldp x29, x30, [sp], 32 # 后索引
10  ret
```

上面是书中的例子：

- cube 在地址 3 处，x29（fp）存储的是调用者（即调用cube函数的函数）的 fp，x30（lr）存储的是 cube 函数的返回地址
- 因为 cube 有调用其他函数，所以有使用到 fp 和 lr；所以地址 3 处将 x29、x30 存储到栈帧中，存储在 sp - 32 起始的 16 个字节中。
- 在地址 4 处，fp 寄存器修改为此时的 sp，lr/fp 的值在 `[fp, sp]` 地址上面
- 在地址 6 处会将 lr 寄存器更新为地址 7，用作 square 函数的返回地址
- 在地址 9 处会将保存的 lr，fp 寄存器旧值从 cube 函数栈帧中恢复到对应的寄存器中，然后释放栈帧
- 地址 10 通过 lr 寄存器返回到调用者

这里细节很多，一个个讲

首先，cube 函数栈帧，也就是被调用者函数负责保存调用者的 fp，假如 cube 还要调用其他函数，栈帧中还会保存 lr，lr 是调用者在 bl 之前设置的。假如 cube 不调用其他函数，就不需要保存 lr。

那么这相比 x86 的 call、ret 有什么区别呢？好处就在于假如被调用的函数没有调用其他函数，直接从 LR 寄存器中恢复返回地址就少了两次内存引用，如果程序有许多这样的新函数，就会大大加快运行效率。x86 也有使用栈帧寄存器 rbp，思路和这里的 fp 寄存器一致。

使用索引寻址，可以让访存指令保存、恢复 lr、fp 值的同时，减小 sp 寄存器的值，在一条指令内完成 `FP/LR 保存与恢复` 和 `栈帧的创建和释放` 这两个任务。两条指令在函数中的位置，数据的修改是完全堆成的，这是为了在函数生命周期结束后消除对栈和寄存器状态的影响。


## 5. 调用惯例

函数的被调用者和调用者的协调称为 calling convention， 由编译器实现该规范

通用寄存器中：

- x9~x15 调用者保存
- x19~x28 被调用者保存
- x0~x7 用来传递前8个参数，x0 用来返回值

在传递实参的过程中，假如参数个数超过 8 个，那么调用者在执行 bl 指令之前，会将参数保存到运行时栈上，称为参数构造区。


**栈帧结构**：

![img](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230409_092359.png)
**调用者栈帧**：属于在调用者函数中执行所产生的内存，具体是 LP''、FP'' 加上 `FP' ~ 被调用者栈帧` 的内容，这里只有参数构造区。

- **调用者的参数构造区**：由于在 bl 指令前执行，属于调用者的栈帧，保存多余的参数

**被调用者栈帧**：属于在调用者函数中执行所产生的内存，具体是 参数保存区~FP 加上 `FP ~ SP` 的内容，

- **被调用者的参数保存区**：在低优化级别，函数开始时将所有的实际参数拷贝到栈帧的参数保存区，方便函数使用；在高优化级别：函数开始时将实际参数保存到被调用者保存寄存器，当调用其他函数时，他们会自动保存这些参数值
- **被调用者的被保存的寄存器**：保存被调用者保存寄存器值
- **被调用者的局部变量区**：保存局部变量
- **LP'、FP’**：当该函数有调用其他函数，在该函数的开头就会保存这两个寄存器值

> 书中的意思大概是 FP 不是指向真正的栈帧开头？

不是每个函数都需要栈帧，所以编译器就不会为每个函数都分配战阵

## 6. 小结

> 运行时，如何依赖于处理器
> 调用和返回时，处理器？

执行本质上是机器指令序列的执行，由 PC 确定下一个要执行的代码。执行过程分为：顺序、跳转。跳转执行在实现分支、循环，依靠状态寄存器的条件码决定跳转；运算将数据从内存加载到通用寄存器，运算完毕后将结果写回内存。

函数调用时，同样寄存器和内存将参数传递给被调用者；被调用者在运行时使用的本地变量和返回地址保存在运行战中，通过栈寄存器保存栈顶


**FAQ**：

**1.调用者保存寄存器和被调用者保存寄存器的区别？优势？**

被调用保存寄存器适合保存生命周期较长，在整个函数内各处都会被使用到的变量
调用者保存寄存器适合保存只在一小块代码中临时用到的变量

因为长变量在调用后还会被用到，需要让被调用者保证还原。短变量不会被用到，调用者干脆不保存不回复
既有调用者保存寄存器，又有被调用者保存寄存器，是为了发挥长变量又有短变量各自的优势。

**2.编译器如何计算每个函数的栈帧？**

局部数量数目、要保存的参数和寄存器数目都可以对函数代码分析可得，所以编译器可以推断栈帧中每一部分是否需要以及分配多少空间。





