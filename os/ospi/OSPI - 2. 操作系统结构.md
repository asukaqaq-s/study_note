
系统设计时常需要考虑如何权衡`(trade off)`，比如在性能与资源利用之间做出权衡。

对于 OS 来说，可以分为两大类的目标：

- 用户目标：方便使用、学习、安全
- 系统目标：容易维护、实现

本章学习的如何降低系统复杂度，讨论一些常用的设计方法和OS架构

- 机制与策略
- 复杂性管理方法
- 操作系统内核架构
- 操作系统应用框架

## 1. 机制与策略

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_043424.png)

降低系统复杂度的重要设计原则是：策略与机制的分离。分离就是策略与机制的代码分别实现，而不耦合。分离带来的好处有：

- OS 通过改变策略，不需要机制的代码实现
- OS 通过优化机制的代码，不需要改变策略代码就能够提升策略的效率


## 2. 复杂性的管理方法

管理复杂性的方法是：M.A.L.H 方法，即：

- 模块化（modularity）
- 抽象（Abstraction）
- 分层（Layering）
- 层级（Hierarchy）


### 2.1 模块化

将系统分为多个模块，按照明确的接口进行交互。划分模块需要保证高内聚和低耦合：

- 模块有独立性
- 模块内较多交互
- 避免模块间联系过多

减少模块间交互是 M.A.L.H 方法的本质，下面三点主要是围绕减少交互的设计

### 2.2 抽象

在模块化的基础上，分为 **接口** 和 **具体实现** ：

- 模块间使用接口不需要知道具体实现
- 依从于模块间边界，尽可能减少模块间交互
- 宽进严出原则：接口可以容纳各种可能的错误输入，但是需要尽可能排除错误的输出

### 2.3 分层

将模块分为多个层次，每层只能和同层模块、相邻模块进行交互，以减少模块间交互。一般先构造底层模块，通过底层模块的功能与服务进一步构造上层模块，比如前面的内核、系统服务、应用框架。

分层也会带来虚拟化，虚拟化能够提升资源利用率（比如 虚拟文件系统、jvm）和可移植性（比如 sqlite 的 OS 层）

### 2.4 层次

将多个功能相近、有关联的模块，组成一个更大的有明确接口的子系统。

层次与分层的区别：

- 分层：不同类模块的层次化
- 分层：同类模块组成一个新模块

## 3. 内核架构

随着计算机的发展，合理的层次结构、结构，能够减少系统的复杂性，提升OS的效率、安全可靠性，这里对常见的 OS 架构进行介绍，并且讨论不同架构如何考虑 `效率` 和 `安全可靠` 的  `trade off`

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_050556.png)

### 3.1 简单内核

简单操作系统将应用程序与操作系统放置在同一个地址空间，以同样的权限运行，无需底层硬件的内存管理，特权级隔离。

- 优点：不需要切换地址空间、特权级别，性能高
- 缺点：隔离性能差、不安全；不利于操作系统的发展

常用于一些没有内存管理的 CPU，用于 RTOS。效率高，安全性差。

### 3.2 宏内核

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_083012.png)
最著名的就是 Linux，同时他也采用了 M.A.L.H 方法管理复杂度：

- **模块化**：分为多个子模块，进程管理、文件系统等；现代操作系统还使用 LKM、EBPF 加载子模块
- **抽象**：文件抽象、虚拟内存抽象等
- **分层**：比如文件系统的分层（也可以想到很多数据库系统中分为SQL和存储层）
- **层次**：进程队列中分为多层队列；进程组分层；内存管理器对不同类型内存的分层

宏内核的优点就是效率高，缺点主要是安全和可靠性
![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_083937.png)

### 3.3 微内核

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_084406.png)
微内核将单个模块、功能从内核冲拆分出来，作为一个服务部署到用户态下，内核只保留必要的功能，为服务提供通信能力（IPC），以协作完成 OS 的基本功能。

微内核改善了宏内核的几个问题：

- **隔离性**：用户态的模块即使发生错误，也不会引起整个内核崩溃
- **策略与机制分离**：内核实现机制，而服务实现策略，可以有效地提高 OS 对特定 workload 的服务

先后经历了 Mach、L4、SeL4 几个微内核，其中 SeL4 引入了形式化证明方法

微内核只是一种设计概念，没有明确什么模块位于内核态，什么位于用户态，L4 提出了微内核的最小化原则：

- 将OS的功能尽可能放到内核态外
- 只有放到内核态外会影响整个系统的功能、效率，才放入到内核态下

这样将整个 OS 分为：微核（极小的、位于内核态下运行）、服务、和高性能的IPC。

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_085616.png)

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230406_085643.png)

### 3.4 外核

OS 管理硬件主要功能是：资源抽象和多路复用。前面几种架构的资源抽象存在以下问题：

- 过度的硬件抽象会带来较大的性能损耗
- OS 的硬件抽象过于通用，对于单个硬件往往不是最优解

为了优化 OS 的性能，外核从资源抽象的方面入手。

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_103731.png)
外核架构中：将管理应用的功能放在内核态的外核中，而将服务应用的功能放在用户态下。

- 因为内核态外核的存在，内存管理、进程隔离处于内核态，能够保证应用执行的安全
- 由应用来管理硬件的抽象，能够选择抽象的最优解，增加资源利用的效率，从而提升应用性能

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_113417.png)

为了降低应用开发的复杂度，外核 OS 提供了一些库，称为 LibOS，将硬件抽象封装到库中，当应用使用库功能时，库和应用链接成为一个可执行程序，内核负责管理这些应用进程。

开发者可以自己选择已有的库，或者自己开发 LibOS。内核负责实现硬件资源的多路复用、资源回收分配。

**优点** 

- OS无抽象，能在理论上提供最优性能
- 应用对计算有更精确的实时等控制
- LibOS在用户态更易调试，调试周期更短 

**缺点** 

- 对计算资源的利用效率主要由应用决定 
- 定制化过多，导致维护难度增加


> 外核与宏内核、微内核的资源利用就是定制和通用的区别，根据不同 workload 定制，肯定是优于通用的性能

### 3.5 多内核

产生多内核架构的原因：

- OS内部维护很多共享状态

	- Cache一致性的保证越来越难
	- 可扩展性非常差，核数增多，性能不升反降

- GPU等设备越来越多 
	 
	 • 设备本身越来越智能——设备有自己的CPU 
	 • 通过PCIe连接，主CPU与设备CPU之间通信非常慢 
	 • 通过系统总线连接，异构SoC（System on Chip）

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_114812.png)

**优点**：

- 避免隐式共享，易于拓展
- 容易支持异构处理器架构

**缺点**：

- 不同节点状态存在冗余
- 上层应用间需要多内核提供的进程通信接口才能交互；性能不一定优秀


### 3.6 混合内核

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_114726.png)


- 微内核将更多功能放在内核态下
- 宏内核 Linux 引入了用户态驱动、用户态协议栈...


## 4. 操作系统框架

现代操作系统一般由 内核 和 框架（系统框架、应用框架） 组成。系统框架借鉴了微内核的思想，将框架组件化、服务化，进程间通信交互。

### 4.1 Android

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_123910.png)


- **硬件抽象层**：和linux设备驱动的接口解耦合，帮助android框架的独立演进与升级；封装硬件实现，提供用户态驱动框架，设备厂商不需要开源
- **android 库**：自定义库
- **android 运行时**：早期虚拟机；5.0 后预先编译 AOT，避免运行时编译开销
- **应用框架**：服务管理、包管理、窗口管理等

在应用框架层采用了组件服务器的结构，通过 Binder IPC 进行交互：

- 服务管理组件负责各个服务组件的注册与管理
- 应用通过服务管理组建完成服务发现，通过 PIC 调用组件请求服务

### 4.2 ROS

![IMG](https://image-1309461627.cos.ap-nanjing.myqcloud.com/image/markdown/os/f3/clipboard_20230407_010901.png)

ROS 是面对机器人的系统服务框架；实现了底层复杂的异构硬件资源抽象；在应用层服务组件化，提供了服务之间和应用服务之间交互的 IPC 机制。

### 4.3 worse is better？

采用两种方法设计 OS：

- **mit 方法**：接口简单比实现简单重要，因此需要保证实现百分百正确
- **新泽西方法**：实现简单比接口简单重要；可以为了简单牺牲准确性


### 5. FAQ

**1. 微内核与外核区别，优劣势**

**区别**：

- **LibOS**：将硬件资源分区，每个区域中的资源用来服务一个应用；**微内核服务**：将服务模块作为单独进程，为 OS 中所有应用提供服务
- **外核**：内核除了必要功能外，主要为 LibOS 提供多路复用；**微内核**：内核主要提供服务的 IPC
- **外核**：定制化 LibOS，性能高；**微内核**：需要复杂的优化 IPC 才能达到外核的性能

微内核优势安全、可靠、易于拓展和开发；外核优势：性能高

**2. 微内核与简单结构**

简单结构不代表是微内核，简单结构是所有程序均处于应用态

**3. 机制、策略

- **先进先出换页**：策略
- **O(1)调度队列**：机制
- **基于 B+树的文件结构**：机制

**4. 策略与机制分离**

**操作系统**：调度算法与进程队列设计；
**数据库系统**：存储引擎与B+、LSMT；事务与死锁避免机制；

**5. 微内核架构的主要性能瓶颈与如何优化**

主要瓶颈：模块间交互

**优化**：

- 交互多的模块重新设计模块
- 将影响大的模块放入内核态
- L4 的信息传参、寄存器传参

**6. 多内核的优缺点**

- 不同节点状态存在冗余（多个副本等）
- 上层应用间需要多内核提供的进程通信接口才能交互；性能不一定优秀